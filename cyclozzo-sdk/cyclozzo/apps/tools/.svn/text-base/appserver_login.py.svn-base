#!/usr/bin/env python
#
# Copyright 2010 K7 Computing Private Limited.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""Helper CGI for logins/logout in the development application server.

This CGI has these parameters:

  continue: URL to redirect to after a login or logout has completed.
  email: Email address to set for the client.
  admin: If 'True', the client should be logged in as an admin.
  action: What action to take ('Login' or 'Logout').

To view the current user information and a form for logging in and out,
supply no parameters.
"""


import cgi
import Cookie
from hashlib import md5
import os
import sys
import urllib
import logging

from cyclozzo.apps.api import apiproxy_stub_map
from cyclozzo.apps.api import user_service_pb
from cyclozzo.apps.runtime import apiproxy_errors

CONTINUE_PARAM = 'continue'
LOGIN_PARAM = 'login'
ADMIN_PARAM = 'admin'
ACTION_PARAM = 'action'
PASSWD_PARAM = 'password'

LOGOUT_ACTION = 'Logout'
LOGIN_ACTION = 'Login'

LOGOUT_PARAM = 'action=%s' % LOGOUT_ACTION

COOKIE_NAME = 'dev_appserver_login'


def GetUserInfo(http_cookie, cookie_name=COOKIE_NAME):
  """Get the requestor's user info from the HTTP cookie in the CGI environment.

  Args:
    http_cookie: Value of the HTTP_COOKIE environment variable.
    cookie_name: Name of the cookie that stores the user info.

  Returns:
    Tuple (email, admin) where:
      email: The user's email address, if any.
      admin: True if the user is an admin; False otherwise.
  """
  cookie = Cookie.SimpleCookie(http_cookie)

  cookie_value = ''
  if cookie_name in cookie:
    cookie_value = cookie[cookie_name].value

  email, admin, user_id = (cookie_value.split(':') + ['', '', ''])[:3]
  return email, (admin == 'True'), user_id


def CreateCookieData(email, admin, username):
  """Creates cookie payload data.

  Args:
    email, admin: Parameters to incorporate into the cookie.

  Returns:
    String containing the cookie payload.
  """
  admin_string = 'False'
  if admin:
    admin_string = 'True'
  if email:
    user_id_digest = md5(email.lower()).digest()
    user_id = '1' + ''.join(['%02d' % ord(x) for x in user_id_digest])[:20]
  else:
    user_id = ''
  return '%s:%s:%s' % (email, admin_string, username)


def SetUserInfoCookie(email, admin, username, cookie_name=COOKIE_NAME):
  """Creates a cookie to set the user information for the requestor.

  Args:
    email: Email to set for the user.
    admin: True if the user should be admin; False otherwise.
    cookie_name: Name of the cookie that stores the user info.

  Returns:
    'Set-Cookie' header for setting the user info of the requestor.
  """
  cookie_value = CreateCookieData(email, admin, username)
  set_cookie = Cookie.SimpleCookie()
  set_cookie[cookie_name] = cookie_value
  set_cookie[cookie_name]['path'] = '/'
  return '%s\r\n' % set_cookie


def ClearUserInfoCookie(cookie_name=COOKIE_NAME):
  """Clears the user info cookie from the requestor, logging them out.

  Args:
    cookie_name: Name of the cookie that stores the user info.

  Returns:
    'Set-Cookie' header for clearing the user info of the requestor.
  """
  set_cookie = Cookie.SimpleCookie()
  set_cookie[cookie_name] = ''
  set_cookie[cookie_name]['path'] = '/'
  set_cookie[cookie_name]['max-age'] = '0'
  return '%s\r\n' % set_cookie


LOGIN_TEMPLATE = """<html>
<head>
	<title>Login</title>
</head>
<body>

<form method='post' action='%(login_url)s'
		style='text-align:center; font: 13px sans-serif'>
	<div style='width: 20em; margin: 1em auto;
				text-align:left;
				padding: 0 2em 1.25em 2em;
				background-color: #d6e9f8;
				border: 2px solid #67a7e3'>
	<div style='text-align:center'>Cyclozzo Login</div>
	<h3>%(login_message)s</h3>
	<p style='padding: 0; margin: 0'>
		<label for='login' style="width: 3em">Login:</label>
		<input name='login' type='text' value='%(login)s' id='login'/>
	</p>
	<p style='padding: 0; margin: 0'>
		<label for='password' style="width: 3em">Password:</label>
		<input name='password' type='password' id='password'/>
	</p>
	<p style='margin-left: 3em'>
		<input name='action' value='Login' type='submit'
			id='submit-login' />
	<input name='action' value='Logout' type='submit'
			id='submit-logout' />
	</p>
	</div>
	

		<p> %(message)s </p>

	
	<input name='continue' type='hidden' value='%(continue_url)s'/>
</form>

</body>
</html>
"""


def RenderLoginTemplate(login_url, continue_url, username, msg):
  """Renders the login page.

  Args:
    login_url, continue_url, email, admin: Parameters passed to
      LoginCGI.

  Returns:
    String containing the contents of the login page.
  """
  login_message = 'Not logged in'
  if username:
    login_message = 'Logged in'

  template_dict = {


    'login': username or 'admin',
    'login_message': login_message,
    'login_url': login_url,
    'continue_url': continue_url,
    'message': msg
  }

  return LOGIN_TEMPLATE % template_dict


def LoginRedirect(login_url,
                  hostname,
                  port,
                  relative_url,
                  outfile):
  """Writes a login redirection URL to a user.

  Args:
    login_url: Relative URL which should be used for handling user logins.
    hostname: Name of the host on which the webserver is running.
    port: Port on which the webserver is running.
    relative_url: String containing the URL accessed.
    outfile: File-like object to which the response should be written.
  """
  dest_url = "http://%s:%s%s" % (hostname, port, relative_url)
  redirect_url = 'http://%s:%s%s?%s=%s' % (hostname,
                                           port,
                                           login_url,
                                           CONTINUE_PARAM,
                                           urllib.quote(dest_url))
  outfile.write('Status: 302 Requires login\r\n')
  outfile.write('Location: %s\r\n\r\n' % redirect_url)


def LoginCGI(login_url,
             username,
             action,
             set_username,
             passwd,
             continue_url,
             outfile):
  """Runs the login CGI.

  This CGI does not care about the method at all. For both POST and GET the
  client will be redirected to the continue URL.

  Args:
    login_url: URL used to run the CGI.
    email: Current email address of the requesting user.
    action: The action used to run the CGI; 'Login' for a login action, 'Logout'
      for when a logout should occur.
    set_email: Email to set for the user; Empty if no email should be set.
    continue_url: URL to which the user should be redirected when the CGI
      finishes loading; defaults to the login_url with no parameters (showing
      current status) if not supplied.
    outfile: File-like object to which all output data should be written.
  """
  redirect_url = ''
  output_headers = []

  msg = ''
  authenticated = False
  if action:
    if action.lower() == LOGOUT_ACTION.lower():
      output_headers.append(ClearUserInfoCookie())
    elif set_username:
      req = user_service_pb.AuthenticateRequest()
      resp = user_service_pb.AuthenticateResponse()
      req.set_username(set_username)
      passwd_hash = md5(passwd).hexdigest()
      req.set_passwd_hash(passwd_hash)
      try:
        apiproxy_stub_map.MakeSyncCall('user', 'Authenticate', req, resp)
      except apiproxy_errors.ApplicationError, e:
        if (e.application_error ==
          user_service_pb.UserServiceError.REDIRECT_URL_TOO_LONG):
          raise RedirectTooLongError
        else:
          raise e

      authenticated, set_email, set_admin, msg = resp.get_auth_result()
      logging.debug('------- %r %r %r %r' %(authenticated, set_email, set_admin, msg))
      if authenticated:
        output_headers.append(SetUserInfoCookie(set_email, set_admin, set_username))

    redirect_url = continue_url or login_url
    for header in output_headers:
	  outfile.write(header)

  if authenticated and redirect_url:
    outfile.write('Status: 302 Redirecting to continue URL\r\n')
    outfile.write('Location: %s\r\n' % redirect_url)
    outfile.write('\r\n')
  else:
    outfile.write('Status: 200\r\n')
    outfile.write('Content-Type: text/html\r\n')
    outfile.write('\r\n')
    outfile.write(RenderLoginTemplate(login_url,
                                      continue_url,
                                      username,
                                      msg))


def main():
  """Runs the login and logout CGI script."""
  form = cgi.FieldStorage()
  login_url = os.environ['PATH_INFO']
  username = os.environ.get('USER_ID', '')

  action = form.getfirst(ACTION_PARAM)
  set_username = form.getfirst(LOGIN_PARAM, '')
  passwd = form.getfirst(PASSWD_PARAM, '')
  continue_url = form.getfirst(CONTINUE_PARAM, '')

  LoginCGI(login_url,
           username,
           action,
           set_username,
           passwd,
           continue_url,
           sys.stdout)
  return 0


if __name__ == '__main__':
  main()
