'''
Cyclozzo Satellite RPC daemon client library
@author: Stanislav Yudin
'''
import os, logging, socket, proto
from cyclozzo.sdk.app import get_yaml
from cyclozzo.runtime.lib import satellite_pb2
from cyclozzo.runtime.lib.satellite_pb2 import *

log = logging.getLogger(__name__)
	
class SatelliteProxy(object):
	'''
	Class provides short-cut methods
	to work with running satellite instance
	'''
	
	def __async_callback(self, data):
		pass		
	
	def __init__(self, target_address, port = 10001):
		'''
		Creates rpc proxy to target server
		rarget is cyclozzo.runtime.model.srv.Server
		'''
		self.target_address = target_address
		log.info('getting satellite rpc to %s:%s' % (self.target_address, port))
		self.stub = Cyclozzo_Satellite_Stub(proto.ProtoChannel(self.target_address, port, satellite_pb2))

	def close(self):
		self.stub.rpc_channel.sock.close()

	def list_instances(self):
		log.info('listing instances on satellite');
		req = SAT_ListInstancesRequest()
		controller = proto.ProtoController()
		lst = self.stub.list_instances(controller, req, self.__async_callback)
		log.debug('%d instances returned by satellite' % lst.instance_count)
		return lst.instances
		
	def list_applications(self):
		log.info('listing applications on satellite')
		req = SAT_ListApplicationsRequest()
		controller = proto.ProtoController()
		lst = self.stub.list_applications(controller, req, self.__async_callback)
		log.debug('%d applications are available on satellite' % lst.applications_count)
		return lst.applications
		
	def is_instance_running(self, app_inst):
		log.info('checking %s (port:%d, name:%s) runs on %s' % (app_inst, app_inst.port, app_inst.app.name, self.target_address))
		pidfile = os.path.join('/var/cyclozzo/apps', 
							app_inst.app.name,
							str(app_inst.app.get_active_revision().revision),
							str(app_inst.port),
							'pidfile')
		inst_list = self.list_instances()
		log.debug('%d total instances' % len(inst_list))
		for inst in inst_list:
			if inst.port == app_inst.port and inst.name == app_inst.app.name:
				return True
		#not found		
		return False
	
	def start_app_instance(self, app_name, app_revision, mcycles_per_minute, request_timeout, proc_memory_limit):
		'''
		Starts application on target server
		returns port where app is running
		'''
		
		log.debug('starting app %s rev.%d' % (app_name, app_revision))
		req = SAT_StartApp(app_name = app_name, app_revision = app_revision, 
				mcycles_per_minute = mcycles_per_minute, request_timeout = request_timeout, 
				proc_memory_limit = proc_memory_limit)
		controller = proto.ProtoController()
		result = self.stub.start_application(controller, req, self.__async_callback)
		if result.pid <= 0 or result.port <= 0:
			log.error('incorrect answer in start_app_instance')
			return -1
		else:
			log.debug('%s started with pid %s on %s:%d' % (app_name, result.pid, self.target_address, result.port))
			return result.port
			
	def stop_app_instance(self, app_name, app_revision, app_port):
		'''
		Stops application instance
		'''
		log.debug('stopping instance of %s(rev#%d) on port %d' % (app_name, app_revision, app_port) )
		req = SAT_StopApp(app_name = app_name, app_revision = app_revision, app_port = app_port)
		controller = proto.ProtoController()
		result = self.stub.stop_application(controller, req, self.__async_callback)
		if result.code !=0:
			log.error('incorrect answer in stop_app_instance')
			return False
		else:
			log.debug('app instance was sucessfully stopped')
			return True

	def upload_file(self, source, save_to = None):
		'''
		Upload file from local fs to server with RPC
		returns True on success, False on fail
		'''
		abs_source = os.path.abspath(source)
		if save_to == None:
			save_to = os.path.join('/tmp', os.path.basename(abs_source))
		
		log.debug('uploading rpc file from "%s" to "%s"' % (abs_source, save_to) )
	
		req = SAT_ReceiveFile()
		req.file_size = int(os.stat(abs_source).st_size)
		req.save_path = save_to
		controller = proto.ProtoController()
		result = self.stub.receive_file(controller, req, self.__async_callback)
	
		if result.receive_port <= 1024:
			log.fatal('rpc responded with broken upload confirm: %d' % result.receive_port)
			return False
	
		# Send the data
		log.debug('Sending data to port %d' % result.receive_port)
		sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		try:
			sock.connect((self.target_address, result.receive_port))
			total_size = 0
			with open(abs_source, 'rb') as f:
				while True:
					data = f.read(8192)
					if len(data) > 0:
						send_size = sock.send(data)
						total_size += send_size
					else:
						break
			log.debug('%d bytes out of %d expected sent to socket' % (total_size, req.file_size))
			sock.close()
		except Exception, e:
			log.error('Error uploading application: %s' %str(e))
			return False
	
		log.debug('%s uploaded to %s' %(source, result.save_path))
		return True
	
