'''
Cyclozzo Master RPC daemon client library
@author: Stanislav Yudin
'''
import os
import logging
import socket
import base64
import time
import datetime

from cyclozzo.sdk.app import get_yaml
from cyclozzo.runtime.lib import master_pb2 as pb2
from cyclozzo.runtime.lib.master_pb2 import *
from cyclozzo.rpc.channel import SocketRpcChannel
from cyclozzo.rpc.service import RpcService

from cyclozzo.runtime.model import Activity

log = logging.getLogger(__name__)

class MasterRpcError(Exception):
	pass
	
class MasterProxy(object):
	'''
	Class provides short-cut methods
	to work with running master instanc
	'''
	
	def __init__(self, address, port = 7771):
		'''
		Creates rpc proxy to target master
		'''
		self.target_address = address
		log.info('getting master rpc to %s:%s' % (self.target_address, port))
		self.service = RpcService(Cyclozzo_Master_Stub, port, self.target_address)

	def close(self):
		""" Placeholder (for backward compatibility)
		"""
		pass

	def callback(self, request, response):
		""" Async callback
		"""
		log.info('Asynchronous response :' + response.__str__())

	def connect(self):
		'''
		Request to master for:
			token - id for the rest of methods
			thrift_address
			thirft_port
		'''
		req = MST_Connect()
		req.ip_address = 'FIXME-SELF-ADDRESS-HERE'
		req.version = 1
		result = self.service.connect(req)
		if not result.token or not result.thrift_address or not result.thrift_port:
			raise MasterRpcError('Malformed answer in :connect')

		return result

	def enum_plugins(self, token):
		'''
		Enumerates plugins on master
		'''
		log.info('[%s] enumerating plugins on server %s' % (token, self.target_address))
		req = MST_EnumPlugins(token = token)
		plg = self.service.enum_plugins(req)
		log.debug(' -> %d plugins known' % plg.plugins_count)
		return plg
	
	def report_api_stats(self, token, stats_dict):
		'''
		Report api usage statistics to master 
		instance
		'''
		stats_dict['token'] = token
		req = MST_ApiStats(**stats_dict)
		log.debug('reporting api stats to master at %s' % self.target_address)
		return self.service.report_api_stats(req)
	
	def cluster_operation(self, token, cloud_key, command):
		log.info('[%s] performing cluster operation %s on cloud %s' % (token, command, cloud_key))
		req = MST_ClusterOperation(token = token,
						cloud_key = str(cloud_key),
						command = command)
		answer = self.service.cluster_operation(req)
		if answer.op_code == 0 and answer.activity_key:
			log.info('received activity key %s' % answer.activity_key)
			return Activity.get(answer.activity_key)
		else:
			log.error('Failed to operate cluster. op_code: %d.' % answer.op_code)
			return None
	
	def deploy_role(self, token, user_key, srv_key, role_key, options):
		log.info('[%s] deploying role %s on server %s' % (token, role_key, srv_key) )
		log.debug('options: %s' % repr(options))
		req = MST_DeployRole(token = token,
						user_key = str(user_key),
						server_key = str(srv_key),
						role_key = str(role_key),
						options_count = len(options))
		for opt in options:
			option = req.options.add()
			value = options[opt]
			if value.__class__ == bool:
				option.type = 'bool'
			else:
				option.type = 'string'

			option.data = str(value)
			option.name = opt
			option.description = opt.capitalize() + ' option'
		
		answer = self.service.deploy_role(req)
		if answer.op_code == 0 and answer.activity_key:
			log.info('received activity key %s' % answer.activity_key)
			return Activity.get(answer.activity_key)
		else:
			log.error('Failed to spawn activity. op_code: %d.' % answer.op_code)
			return None
			
	def cancel_activity(self, token, user_key, act_key, code = -1, reason = 'No Reason'):
		'''
		Cancels activity on master
		'''
		log.info('[%s] cancel activity %s' % (token, act_key) )
		req = MST_CancelActivity(token = token,
						user_key = user_key,
						act_key = act_key,
						code = code,
						reason = reason)

		answer = self.service.cancel_activity(req)
		if answer.op_code == 0 and \
			answer.activity_key:
			log.debug('Activity %s is now %s' % ( answer.activity_key, Activity.get(answer.activity_key).get_status() ) )
			return True
		else:
			log.error('Malformed answer returned. op_code: %d. activity_key: %s' % (answer.op_code, str(answer.activity_key)))
			return False
			
	def get_activity_proc_log(self, token, act_key):
		'''
		Returns array of log file lines
		of spawned worker process on master
		'''
		log.info('get log of %s' % act_key )
		req = MST_GetActivityProcessLogRequest(token = token,
						act_key = act_key)
		answer = self.service.get_activity_proc_log(req)
		if answer.op_code != 0:
			msg = '[ERROR]: Failed to read activity log. Code %d: %s' % (answer.error.error_code, str(answer.error.error_message))
			log.error(msg)
			return [ msg ]
		elif answer.lines:
			log.info('Log received')
			return answer.lines
		else:
			log.error('Unexpected answer from mater code %d. Error: %s' % (answer.op_code, answer.error_message))
			return ['Error received: %s' % answer.error ]
			
	def authenticate(self, token, auth_dict):
		'''
		Authenticate users.
		'''
		auth_dict['token'] = token
		req = MST_Authenticate(**auth_dict)
		log.debug('reporting to master at %s' % self.target_address)
		answer = self.service.authenticate(req)
		return answer.authenticated, answer.admin, answer.email, answer.message

	def notify_app_started(self, token, app_name, app_revision, server_key, app_port):
		log.debug('reporting instance was started [%s/%s/%d/%d]' % (server_key, app_name, app_revision, app_port))
		req = MST_AppStartNotification()
		req.token = token
		req.code = 0
		req.message = 'New instance of %s(#%s) was started on [%s] port %s successfuly' % (app_name, app_revision,
			server_key, app_port)
		req.app_name = app_name
		req.app_revision = app_revision
		req.server_key = server_key
		req.port = app_port
		resp = self.service.notify_app_started(req)
		
		if resp.op_code == 0:
			return True
		else:
			return False
	
	def notify_app_stopped(self, token, server_key, app_name, app_revision, app_port):
		log.debug('reporting instance was stopped [%s/%s/%d/%d]' % (server_key, app_name, app_revision, app_port))
		req = MST_AppStopNotification()
		req.token = token
		req.code = 0
		req.message = 'An Instance of %s (rev#%d) on %s port %d was stopped' % (app_name, app_revision, server_key, app_port)
		req.app_name = app_name
		req.app_revision = app_revision
		req.app_port = app_port
		req.server_key = server_key
		resp = self.service.notify_app_stopped(req)
		
		if resp.op_code == 0:
			return True
		else:
			return False
			
	def stop_app_balancer(self, token, server_key, app_name, app_revision, app_port):
		log.debug('requesting instance balancer stop [%s/%s/%d/%d]' % (server_key, app_name, app_revision, app_port))
		req = MST_AppStopBalancer()
		req.token = token
		req.app_name = app_name
		req.app_revision = app_revision
		req.app_port = app_port
		req.server_key = server_key
		resp = self.service.stop_app_balancer(req)
		if resp.op_code == 0:
			return True
			log.info('instance balancer stopoped successfuly')
		else:
			return False
		
	def upload_app(self, token, path_to_app, app_name, app_revision):
		'''
		Upload an application tarball to master with RPC
		App is saved in DFS on master
		returns (True, Message) on success, (False, Message) on fail
		'''
		abs_source = os.path.abspath(path_to_app)
		log.debug('uploading application tarball from "%s"' % abs_source)

		req = MST_ReceiveApp()
		req.token = token
		req.file_size = int(os.stat(abs_source).st_size)
		req.app_name = app_name
		req.app_revision = app_revision

		result = self.service.receive_app(req)

		if result.receive_port <= 1024:
			log.fatal('rpc responded with broken upload confirm: %d' % result.receive_port)
			return False, 'Broken port number %d was received' % result.receive_port

		# Send the data
		log.debug('Sending data to port %d' % result.receive_port)
		sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		try:
			sock.connect((self.target_address, result.receive_port))
			total_size = 0
			with open(abs_source, 'rb') as f:
				while True:
					data = f.read(8192)
					if len(data) > 0:
						send_size = sock.send(data)
						total_size += send_size
					else:
						break
			if total_size != req.file_size:
				log.error('Sent %d bytes out of %d bytes in file' % (total_size, req.file_size) )
				return False, 'Sent %d bytes out of %d bytes in file' % (total_size, req.file_size)
			else:
				log.info('Application package %s uploaded to master' % path_to_app)
				return True, 'Application package %s uploaded to master' % path_to_app
		except Exception, e:
			log.error('Error uploading application: %s' %str(e))
			return False, 'Error uploading application: %s' %str(e)
			
		finally:
			sock.close()
	
	def is_app_available(self, token, app_name, app_revision):
		log.debug('checking application %s rev.%d available')
		req = MST_StatApp()
		req.token = token
		req.app_name = app_name
		req.app_revision = app_revision

		answer = self.service.is_app_available(req)
		return (answer.op_code == 0)
		
	def report_app_log(self, token, app_key, app_port, server_key, items):
		log.debug('reporting app %s log = %s' % (app_key, repr(items)))
		req = MST_AppLog( token=token, app_key=app_key, app_port=app_port, server_key=server_key)
		for dt, code, msg in items:
			req.timestamps.append( int(dt) )
			req.codes.append( int(code) )
			req.messages.append( str(msg) )
		log.debug('%d messages are ready to be sent' % len(req.messages))
		answer = self.service.report_app_log(req)
		if answer.op_code == 0:
			log.debug('reported %d log entries' % len(items) )
		else:
			log.error('failed to report application log')
		return (answer.op_code == 0)
		
	def disable_app_quota(self, token, app_key, quota_name, enable_after):
		log.debug('disabling app %s for %d seconds' % (app_key, enable_after) )
		req = MST_AppDisableQuotaRequest()
		req.token = token
		req.app_key = app_key
		req.enable_after = enable_after
		#req.local_time = int(time.mktime(datetime.datetime.now().timetuple()))
		req.quota_name = quota_name
		
		resp = self.service.disable_app_quota(req)
		log.debug('master replyed with timeout %d' % resp.timeout)
		return resp
		
